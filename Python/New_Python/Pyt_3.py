# Даны строковые представления чисел: 
# '011011101' (двоичная СС), 
# '357' (восьмеричная СС) 
# и 'AF23D' (шестнадцатеричная СС). 
# Выведите на экран строковые представления этих чисел в десятичной системе счисления

# bin = "011011101"
# print (int(bin, base=2))

# oct = "357"
# print (int(oct, base = 8))

# hex = "AF23D"
# print (int(hex, base = 16))


# Зная, что 1372 является числом в восьмеричной системе счисления, 
# выведите на экран значение этого числа в десятичной системе счисления

# x = "1372"
# print (int(x, base = 8))



# №1.4.* Представьте вещественные числа 275.4, 0.0032 и 3.45 
# в коде Python в стандартном виде. 
# Напомним, что в математике число в такой форме имеет вид 
# a*10n, где 1 ≤ a < 10, а n – целое число. Например, для числа 0.123 получим 1.23*10-1.

# print (2.754e2)
# print(3.2e-3)
# print (3.45e0)


# №1.5.* Найдите наименьшую обыкновенную дробь, равную вещественному числу 14.375, 
# и выведите ее на экран в формате '14.375 = числитель/знаменатель'.

# x = 14.375
# y = int(x)
# z = x%1
# print (f"{y*100} / {z*1000}")

# x = 14.58
# num = 0.75.as_integer_ratio()
# print(num)


# c = 7.5+1.35j
# print('Комплексное число', c)
# # Выведет 7.5.
# print('Действительная часть числа:', c.real)
# # Выведет 1.35.
# print('Мнимая часть числа:', c.imag)
# # Выведет 7.5-1.35j.
# print('Сопряженное к 7.5+1.35j:', c.conjugate())


# 1.7.* Даны два действительных числа a и b. 
# Вычислите их сумму, разность, произведение и частное 
# при a=3.79 и b=84.93. 
# Округлите результаты до сотых и выведите их на экран

# a = 3.79
# b = 84.93

# print ("Сумма равна:", round (a+b, 2))
# print (f"Разность равна: {round(a-b, 2)}")
# print (f"Произведение равна: {round(a*b, 2)}")
# print (f"Частность равна: {round(a/b, 2)}")


# 1.8.* Вычислите значение выражения (10/2.3 - 3^4)*0.7 + 9^0.5, 
# округлив результат до трех знаков после десятичной точки и найдя его модуль.

# a = (10/2.3 - 3**4) * 0.7 + 9**0.5

# print (f"Равно:  {round (a, 3)}")
# if a < 0:
#     print (f"Модуль равен {round (a*-1,3)}")


# def mult_two(a: int, b: int):
#    a = int(input())
#    b = int(input())
#    return a * b


# print("Example")
# print(mult_two(1, 2))

# assert mult_two(3, 2) == 6
# assert mult_two(0, 1) == 0

# print("The first mission is done! Click 'Check' to earn cool rewards!")




# Вам дан список целых чисел. Ваша задача в этой миссии 
# — удвоить все нули в заданном списке

# a = []
# b = [1,8,0,2,4,4]

# for i in b:
#     if i == 0:
#         a.append(i)
#         a.append(0)
        
#     else:
#         a.append(i)
# print (a)


# def duplicate_zeros(list):
    
#     for i in list:
#         if i == 0:
#             list2.append(i)
#             list2.append(0)
#         else:
#             list2.append(i)
   
#     return list2

# list = []
# list2=[]    

# print("Example:")
# # print(duplicate_zeros([1, 0, 2, 3, 0, 4, 5, 0]))

# # print (duplicate_zeros([0, 0, 0, 0])) 

# print ("[100, 10, 0, 101, 1000] ==", duplicate_zeros([100, 10, 0, 101, 1000]))

# print("The mission is done! Click 'Check Solution' to earn rewards!")
    
  
# 1. Создать произвольный список
# 2. Добавить новый элемент типа str в конец списка
# 3. Добавить новый элемент типа int на место с индексом
# 4. Добавить новый элемент типа list в конец списка
# 5. Добавить новый элемент типа tuple на место с индексом
# 6. Получить элемент по индексу
# 7. Удалить элемент
# 8. Найти число повторений элемента списка

# spisok = [1,2,3,4,5]
# spisok.append("stroka")
# spisok[0] = 99
# spisok.append(["t","yhdhd","u"])
# spisok[-3]=(99,99,99)
# s = spisok[4]
# spisok.remove(99)
# spisok.count(2)

# print(spisok.count(2))
# print(s)

# Получите первый и последний элемент списка
# spisok = [1,2,1,1,3,4,5,5,5,5]
# end = spisok[-1]
# per = spisok[0]
# st = set(spisok)
# print (st)


# 1. Создать произвольный словарь
# 2. Добавить новый элемент с ключом типа str и значением типа int 
# 3. Добавить новый элемент с ключом типа кортеж(tuple) и значением типа список(list)
# 4. Получить элемент по ключу
# 5. Удалить элемент по ключу
# 6. Получить список ключей словаря

# slovar = {1: 'van', 2: 'tu', 3: 'fri'}
# slovar[4] = ('rt', 'kj', 'pl')
# a = slovar[4]

# print(slovar.keys)
# print (a)


# 1. Создать множество(set) 
# 2. Создать неизменяемое множество(frozenset) 
# 3. Выполнить операцию объединения созданных множеств
# 4. Выполнить операцию пересечения созданных множеств 

# set = {1,2,3,'str'}
# set_2 = frozenset ({1,2,4,5,6,'sd'})
# a = set|set_2
# b = set&set_2

# print(a)
# print(b)



# Напишите функцию num_sum(a), принимающую любое значение. 
# Если это целое число, то возвратить сумму его чисел. 
# В противном случае возвращается фраза «Это не целое число».

# from ipaddress import summarize_address_range


# def num_sum(a):
    
#     if isinstance(a, int) and not isinstance(a, bool):
#         summa=0
#         a_to_strit = str(abs(a))
#         for i in a_to_strit:
#             summa += int(i)
#         return summa
#     return 'Это не целое число'

# print(num_sum(5123))

# Напишите функцию to_float(num), 
# которая преобразует любое число в число с плавающей точкой.
# Если в качестве аргумента передан другой тип данных, 
# она возвращает «Невозможно преобразовать».

# def to_floaf (num):
#     a=0
#     if isinstance (num,(int, float)):
#         a = float(num)
#         return a
#     else:
#         return 'Невозможно преобразовать'

# print(to_floaf("вав"))


# Напишите функцию округления round_standard(num), 
# принимающую число с плавающей точкой 
# и округляющую его до целого числа в соответствии с правилами школьной математики.

# def round_standart(num):
#     if num >= 0:
#         a = int(num+0.5)
#     else:
#         a = -1*int(abs(num)+0.5)
#     return a

# print (round_standart(-2.3))
        

# Так как в Python операции с вещественными числами могут давать неожиданные результаты 
# (в частности, 0.1 + 0.2 не будет в точности равняться 0.3), стоит задача с этим как-то справляться. 
# Требуется написать функцию eqv(a, b, c), которая принимает 3 числа. 
# Числа a и b складываются. 
# Затем эта сумма сравнивается с числом “с” с определенной степенью точности. 
# Точность равняется 0.01 % от большего из чисел a и b. 
# Функция вернет True, если выполняется равенство, иначе False.

# def eqv(a,b,c):
#     number = round(float(a)+float(b),6)
#     if number == c:
#         return True
#     else:
#         return False

# print (eqv(0.5, 0.3, 0.8))
# def eqv(a, b, c):
#     res = a + b
#     e = 0.01 / 100  # Перевод процентов в долю
#     tolerance = e * max(abs(a), abs(b))  # Находим значение отклонения
#     return abs(res - c) <= tolerance  # Определяем, меньше ли разница, чем отклонени



# Напишите функцию dislike_6(a), которая всегда возвращает True, 
# если только не передается число 6 типа int или типа float (в данном случае она вернет «Только не 6!»).

# def dislike_6(a):
#     if (type(a) is int or type(a) is float) and a==6.0:
#         return 'Только не 6'
#     return True

# print (dislike_6(5.0))

# Изучающий язык Python студент постоянно путается в свойствах логических операций 
# (ассоциативность, дистрибутивность, коммутативность, правило де Моргана). 
# Он решил написать функцию-подсказку help_bool(letter), 
# которая принимает одну из 4 букв: к, а, д, м (соответствующую каждому свойству). 
# Результат выполнения: определенное правило работы в виде строки.
# Если будет передано что-то иное, 
# то вернется подсказка-строка с пояснением по каждому возможному аргументу.

# def help_bool(letter):
#     if letter == 'к':
#         return 'A or B = B or A\nA and B = B and A'
#     elif letter == 'а':
#         return 'A or (B or C) == (A or B) or C == A or B or C\n' \
#                'A and (B and C) == (A and B) and C == A and B and C'
#     elif letter == 'д':
#         return 'A and (B or C) == (A and B) or (A and C) \n'\
#                'A or (B and C) == (A or B) and (A or C)'
#     elif letter == 'м':
#         return 'not(A or B) == not A and not B \n'\
#                'not(A and B) == not A or not B\n'\
#                'not(A < B) == A >= B\n'\
#                'not(not(A)) = A'
#     else:
#         return 'Возможные аргументы: к – Коммутативность, д – Дистрибутивность, а – Ассоциативность, ' \
#            'м – Теорема Де Моргана'

# print (help_bool('м'))

# стала задача написать функцию divider(a, b), 
# принимающую любые 2 числовых параметра. 
# Задача функции: разделить a на b. 
# Если в знаменателе введут ноль, то результат будет следующим: «Нули в знаменателе не приветствуются». 
# В противном случае выводится итог деления чисел, возведенный в куб.
# Решите задание без использования условия if, применяя свойства логических операторов.

# def divider(a,b):
#     return b and (a / b) ** 3 or 'Нули в знаменателе не приветствуются'
# print (divider(2,0))


# Дан произвольный список. 
# Представьте его в обратном порядке.

list = [1,2,3,4,5]
print(list[::-1])
list.reverse()
print(list)



